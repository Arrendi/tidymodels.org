---
title: "Survival Analysis Example"
tags: [survival, tidyposterior, survival analysis, regression models]
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  digits = 3,
  collapse = TRUE,
  comment = "#>"
  )
options(digits = 3)
library(survival)
library(tidymodels)
library(tidyposterior)
theme_set(theme_bw() + theme(legend.position = "top"))
```

In addition to the `tidymodels` package, this example uses the `survival`, and `tidyposterior` packages. 

In this article, a parametric analysis of censored data is conducted and `rsample` is used to measure the importance of predictors in the model. The data that will be used is the NCCTG lung cancer data contained in the `survival` package:

```{r lung}
library(survival)
str(lung)
```

`status` is an indicator for which patients are censored (`status = 1`) or an actual event (`status = 2`). The help file `?survreg` has the following model fit:

```{r example-model}
lung_mod <- survreg(Surv(time, status) ~ ph.ecog + age + strata(sex), data = lung)
summary(lung_mod)
```

Note that the stratification on gender only affects the scale parameter; the estimates above are from a log-linear model for the scale parameter even though they are listed with the regression variables for the other parameter. `coef` gives results that are more clear:

```{r coef}
coef(lung_mod)
```

To resample these data, it would be a good idea to try to maintain the same censoring rate across the splits. To do this, stratified resampling can be used where each analysis/assessment split is conducted within each value of the status indicator. To demonstrate, Monte Carlo resampling is used where 75% of the data are in the analysis set. A total of 100 splits are created.   

```{r splits}
library(tidymodels)
set.seed(9666)
mc_samp <- mc_cv(lung, strata = status, times = 100)

cens_rate <- function(x) mean(analysis(x)$status == 1)
summary(map_dbl(mc_samp$splits, cens_rate))
```

To demonstrate the use of resampling with censored data, the parametric model shown above will be fit with different variable sets to characterize how important each predictor is to the outcome. 

To do this, a set of formulas are created for the different variable sets:

```{r forms}
three_fact <- as.formula(Surv(time, status) ~ ph.ecog + age + strata(sex))
rm_ph.ecog <- as.formula(Surv(time, status) ~           age + strata(sex))
rm_age     <- as.formula(Surv(time, status) ~ ph.ecog +       strata(sex))
rm_sex     <- as.formula(Surv(time, status) ~ ph.ecog + age              )
```

The model fitting function will take the formula as an argument:

```{r fit-func}
mod_fit <- function(x, form, ...) {
  survreg(form, data = analysis(x), ...)
}
```

To calculate the efficacy of the model, the concordance statistic is used (see `?survConcordance`):

```{r concord}
get_concord <- function(split, model, ...) {
  pred_dat <- assessment(split)
  pred_dat$pred <- predict(model, newdata = pred_dat)
  concordance(Surv(time, status) ~ pred, pred_dat, ...)$concordance
}
```

With these functions, a series of models are created for each variable set.

```{r models}
mc_samp <- 
  mc_samp %>% 
  mutate(
    full_mod    = map(splits, mod_fit, form = three_fact),
    ph_ecog_mod = map(splits, mod_fit, form = rm_ph.ecog),
    age_mod     = map(splits, mod_fit, form = rm_age),
    sex_mod     = map(splits, mod_fit, form = rm_sex)
  )
```

Similarly, the concordance values are computed for each model:

```{r concord-est}
mc_samp <- 
  mc_samp %>% 
  mutate(
    full    = map2_dbl(splits, full_mod, get_concord),
    ph_ecog = map2_dbl(splits, ph_ecog_mod, get_concord),
    age     = map2_dbl(splits, age_mod, get_concord),
    sex     = map2_dbl(splits, sex_mod, get_concord)
  )
```

The results are:

```{r concord-df}
concord_est <- 
  mc_samp %>%
  dplyr::select(-ends_with("mod")) 

concord_est %>% 
  select(-splits) %>% 
  pivot_longer(cols = c(-starts_with("id")), names_to = "Removed", values_to = "Concordance") %>% 
  ggplot(aes(x = reorder(Removed, Concordance), y = Concordance)) + 
  geom_line(aes(group = id), alpha = .3) + 
  xlab("Predictor Removed")
```

It looks as though the model missing `ph_ecog` has more of a loss in concordance values than the other models. As one might expect, the full model and the model absent `sex` are very similar; the difference in these models should only be the scale parameters estimates. 

To more formally test this, the `tidyposterior` package is used to create a Bayesian model for the concordance statistics. 

```{r perf-mod, include = FALSE}
library(tidyposterior)
concord_est <- perf_mod(concord_est, seed = 6507, iter = 5000)
```

The actual Bayesian model is:

```{r stan}
concord_est$stan
```

To summarize the posteriors for each model:

```{r post}
concord_est %>% 
  tidy() %>% 
  as_tibble() %>% 
  ggplot(aes(x = posterior, col = model)) + 
  geom_line(stat = "density", trim = TRUE)
```

To compute the posteriors for the difference in models, the full model will be contrasted with the others:

```{r diffs}
comparisons <- contrast_models(
  concord_est, 
  list_1 = rep("full", 3),
  list_2 = c("ph_ecog", "age", "sex"),
  seed = 4654
  )
```

The posterior distributions show that, statistically, `ph_ecog` has real importance to the model. 

```{r diff-post}
ggplot(comparisons) + 
  theme_bw()
summary(comparisons)
```

The effect of `sex` shouldn't be suprising since it only affected the scale parameter in the model. 
